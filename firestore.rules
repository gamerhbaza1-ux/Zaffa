/**
 * Core Philosophy: This ruleset enforces a household-centric data model. Users can only access data within their own profile or within the household they belong to.
 *
 * Data Structure:
 * - `/users/{userId}`: Stores private user profile information, including a `householdId`.
 * - `/households/{householdId}`: A document containing household metadata, like an invite code and a list of member UIDs.
 * - `/households/{householdId}/{collection}`: Subcollections (e.g., `checklistItems`, `categories`) containing the shared data for that household.
 *
 * Key Security Decisions:
 * - User Profile Privacy: A user can only read and update their own profile document. Creation is handled upon signup, and deletion is disallowed from the client.
 * - Household Isolation: A user can only read or write documents within the household they are a member of. This is the core of the sharing model.
 * - Secure Access Check: To access any data within `/households/{householdId}/...`, the rule first fetches the requesting user's profile (`/users/{request.auth.uid}`) to get their `householdId` and verifies it matches the `householdId` in the resource path. This is an efficient way to enforce membership.
 *
 * This structure ensures that two users (e.g., a bride and groom) who share the same `householdId` can both securely access and modify their shared checklist, while keeping it entirely private from other users.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper Functions for re-usable logic

    /**
     * Checks if a user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the currently authenticated user's UID matches the provided userId.
     * This is the primary function for establishing document ownership.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks if the requesting user belongs to the household specified in the path.
     * It does this by reading the user's own profile document to find their householdId.
     */
    function isMemberOfHousehold(householdId) {
      let userDoc = get(/databases/$(database)/documents/users/$(request.auth.uid));
      return isSignedIn() && userDoc.data.householdId == householdId;
    }
    
    /**
     * Checks if the requesting user is a partner of the user specified by userId.
     * Partners are users who share the same non-null householdId.
     */
    function isPartner(userId) {
      let userHouseholdId = get(/databases/$(database)/documents/users/$(request.auth.uid)).data.householdId;
      let otherUserHouseholdId = get(/databases/$(database)/documents/users/$(userId)).data.householdId;
      return isSignedIn() && userHouseholdId != null && userHouseholdId == otherUserHouseholdId;
    }
    
    /**
     * @description Rules for a user's own profile data.
     * @path /users/{userId}
     * @principle A user can read and update their own profile. Creation is handled securely, and deletion is not allowed. Partners can also read each other's profiles.
     */
    match /users/{userId} {
      allow read: if isOwner(userId) || isPartner(userId);
      allow create, update: if isOwner(userId);
      // Delete is not allowed from the client for data integrity.
    }
    
    /**
     * @description Rules for the household document itself.
     * @path /households/{householdId}
     * @principle A member of a household can read and write to it. A non-member can join if they have a valid invite.
     */
    match /households/{householdId} {
       // Any signed-in user can read household metadata (member list). This is needed to allow a user to accept an invitation.
       allow read: if isSignedIn();
       // An existing member can update. A new user can also add themselves to the list if they are not already a member.
       allow update: if isMemberOfHousehold(householdId) || 
                      (isSignedIn() && 
                       request.auth.uid in request.resource.data.memberIds && 
                       !(request.auth.uid in resource.data.memberIds));
       allow delete: if isMemberOfHousehold(householdId);
       // Allow a user to create a household if their UID is in the initial memberIds list.
       allow create: if isSignedIn() && request.auth.uid in request.resource.data.memberIds;
    }

    /**
     * @description Rules for all shared data within a household.
     * @path /households/{householdId}
     * @principle Restricts all access to members of the household.
     */
    match /households/{householdId}/{document=**} {
      allow read, write: if isMemberOfHousehold(householdId);
    }

    match /invitations/{invitationId} {
      allow create: if isSignedIn() && request.resource.data.inviterId == request.auth.uid;
      
      // 'read' covers 'get' and 'list'. For 'list' (queries), `resource` is not available.
      // This rule works for queries like `where('inviteeEmail', '==', request.auth.token.email)`
      // because Firestore can verify `resource.data.inviteeEmail` against the query's constraint.
      allow read: if isSignedIn() && 
                  (request.auth.uid == resource.data.inviterId || request.auth.token.email == resource.data.inviteeEmail);

      allow delete: if isSignedIn() && 
                    (request.auth.uid == resource.data.inviterId || request.auth.token.email == resource.data.inviteeEmail);
    }
  }
}
